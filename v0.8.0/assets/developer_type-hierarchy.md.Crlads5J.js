import{_ as a,c as t,ai as r,o as i}from"./chunks/framework.BjNXNzNQ.js";const m=JSON.parse('{"title":"Inheritance and Traits","description":"","frontmatter":{},"headers":[],"relativePath":"developer/type-hierarchy.md","filePath":"developer/type-hierarchy.md","lastUpdated":null}'),n={name:"developer/type-hierarchy.md"};function s(o,e,c,d,p,l){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="Inheritance-and-Traits" tabindex="-1">Inheritance and Traits <a class="header-anchor" href="#Inheritance-and-Traits" aria-label="Permalink to &quot;Inheritance and Traits {#Inheritance-and-Traits}&quot;">â€‹</a></h1><p>Julia (and in general, all modern languages like Rust or Go) implement Object Oriented Programming (OOP) in a rather restricted form compared to popular OOP languages like Java, C++ or Python. In particular, they forbid <em>structural inheritance</em>; i.e. inheriting fields from parent superclass(es).</p><p>In recent years, <em>structural inheritance</em> has increasingly been considered a bad practice, favouring <em>composition</em> instead.</p><p>Julia design space on this topic is not completely clear. Julia has <em>abstract types</em>, which can be &quot;inherited&quot; but do not have fields and can&#39;t be instantiated, and <em>concrete types</em>, which cannot be inherited from them but have fields and can be instantiated. In this sense, implementing methods with Julia&#39;s abstract types act as some kind of polymorphic base class.</p><p>As of the time of writing, the type hierarchy of Tenet looks like this:</p><p>DocumenterMermaid.MermaidBlock([...])</p><p>DocumenterMermaid.MermaidScriptBlock([...])</p>',7)]))}const u=a(n,[["render",s]]);export{m as __pageData,u as default};
