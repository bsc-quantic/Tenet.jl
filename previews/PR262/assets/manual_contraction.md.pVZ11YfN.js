import{_ as o,c as r,j as e,a as s,G as n,a5 as a,B as l,o as p}from"./chunks/framework.BqptwCCd.js";const y=JSON.parse('{"title":"Contraction","description":"","frontmatter":{},"headers":[],"relativePath":"manual/contraction.md","filePath":"manual/contraction.md","lastUpdated":null}'),c={name:"manual/contraction.md"},d={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""};function k(u,t,g,E,b,m){const i=l("Badge");return p(),r("div",null,[t[6]||(t[6]=e("h1",{id:"contraction",tabindex:"-1"},[s("Contraction "),e("a",{class:"header-anchor",href:"#contraction","aria-label":'Permalink to "Contraction"'},"â€‹")],-1)),t[7]||(t[7]=e("p",null,[s("Contraction path optimization and execution is delegated to the "),e("a",{href:"https://github.com/bsc-quantic/EinExprs",target:"_blank",rel:"noreferrer"},[e("code",null,"EinExprs")]),s(" library. A "),e("code",null,"EinExpr"),s(" is a lower-level form of a Tensor Network, in which the contraction path has been laid out as a tree. It is similar to a symbolic expression (i.e. "),e("code",null,"Expr"),s(") but in which every node represents an Einstein summation expression (aka "),e("code",null,"einsum"),s(").")],-1)),e("details",d,[e("summary",null,[t[0]||(t[0]=e("a",{id:"EinExprs.einexpr-Tuple{TensorNetwork}",href:"#EinExprs.einexpr-Tuple{TensorNetwork}"},[e("span",{class:"jlbinding"},"EinExprs.einexpr")],-1)),t[1]||(t[1]=s()),n(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[2]||(t[2]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">einexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractTensorNetwork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; optimizer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EinExprs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Greedy, output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tn, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Search a contraction path for the given <a href="./@ref"><code>AbstractTensorNetwork</code></a> and return it as a <code>EinExpr</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>optimizer</code> Contraction path optimizer. Check <a href="https://github.com/bsc-quantic/EinExprs.jl" target="_blank" rel="noreferrer"><code>EinExprs</code></a> documentation for more info.</p></li><li><p><code>outputs</code> Indices that won&#39;t be contracted. Defaults to open indices.</p></li><li><p><code>kwargs</code> Options to be passed to the optimizer.</p></li></ul><p>See also: <a href="/Tenet.jl/previews/PR262/api/tensor#Graphs.LinAlg.contract-Tuple{Tensor, Tensor}"><code>contract</code></a>.</p><p><a href="https://github.com/bsc-quantic/Tenet.jl/blob/bf3cb1603a67f842209168786adb6d802c5e356a/src/TensorNetwork.jl#L629-L641" target="_blank" rel="noreferrer">source</a></p>',6))]),t[8]||(t[8]=e("div",{class:"warning custom-block"},[e("p",{class:"custom-block-title"},"Missing docstring."),e("p",null,[s("Missing docstring for "),e("code",null,"contract(::Tenet.TensorNetwork)"),s(". Check Documenter's build log for details.")])],-1)),e("details",h,[e("summary",null,[t[3]||(t[3]=e("a",{id:"Tenet.contract!",href:"#Tenet.contract!"},[e("span",{class:"jlbinding"},"Tenet.contract!")],-1)),t[4]||(t[4]=s()),n(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),t[5]||(t[5]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contract!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorNetwork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span></code></pre></div><p>In-place contraction of tensors connected to <code>index</code>.</p><p>See also: <a href="/Tenet.jl/previews/PR262/api/tensor#Graphs.LinAlg.contract-Tuple{Tensor, Tensor}"><code>contract</code></a>.</p><p><a href="https://github.com/bsc-quantic/Tenet.jl/blob/bf3cb1603a67f842209168786adb6d802c5e356a/src/TensorNetwork.jl#L663-L669" target="_blank" rel="noreferrer">source</a></p>',4))])])}const x=o(c,[["render",k]]);export{y as __pageData,x as default};
