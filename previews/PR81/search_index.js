var documenterSearchIndex = {"docs":
[{"location":"examples/mps-ml/#Matrix-Product-State-classifier","page":"Matrix Product State classifier","title":"Matrix Product State classifier","text":"","category":"section"},{"location":"examples/mps-ml/","page":"Matrix Product State classifier","title":"Matrix Product State classifier","text":"danger: ðŸš§ Broken code ðŸš§\nThere is a lot of work in progress, and this code may not work yet. Take this code as an example of what we want to achieve.","category":"page"},{"location":"examples/mps-ml/","page":"Matrix Product State classifier","title":"Matrix Product State classifier","text":"using Tenet\nusing Zygote\n\nÏˆ = rand(MatrixProductState, 40, 2, 128)","category":"page"},{"location":"examples/mps-ml/","page":"Matrix Product State classifier","title":"Matrix Product State classifier","text":"L(psi) = frac1N sum^N_i=1 left( braketphi(mathbfx^(i)) mid psi - 1 right)^2","category":"page"},{"location":"examples/mps-ml/","page":"Matrix Product State classifier","title":"Matrix Product State classifier","text":"loss(Ïˆ) = 1/N * sum((fidelity(Ïˆ, É¸(sample)) - 1)^2 for sample in dataset)\n\nÎ» = 0.001\nfor it in 1:100\n    âˆ‡ = gradient(loss, Ïˆ)\n    Ïˆ -= Î» * âˆ‡\nend","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Makie\nMakie.inline!(true)\nset_theme!(resolution=(800,400))\n\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\n\nusing Tenet","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Tenet provides a Package Extension for Makie support. You can just import a Makie backend and call Makie.plot on a TensorNetwork.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Makie.plot(::Tenet.TensorNetwork)","category":"page"},{"location":"visualization/#MakieCore.plot-Tuple{TensorNetwork}","page":"Visualization","title":"MakieCore.plot","text":"plot(tn::TensorNetwork; kwargs...)\nplot!(f::Union{Figure,GridPosition}, tn::TensorNetwork; kwargs...)\nplot!(ax::Union{Axis,Axis3}, tn::TensorNetwork; kwargs...)\n\nPlot a TensorNetwork as a graph.\n\nKeyword Arguments\n\ninds Whether to show the index labels. Defaults to false.\nlayout Algorithm used to map graph vertices to a (2D or 3D) coordinate system. The algorithms implemented in the NetworkLayout package are recommended.\n\n\n\n\n\n","category":"method"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"tn = rand(TensorNetwork, 14, 4, seed=0) # hide\nplot(tn, labels=true)","category":"page"},{"location":"contraction/#Contraction","page":"Contraction","title":"Contraction","text":"","category":"section"},{"location":"contraction/","page":"Contraction","title":"Contraction","text":"Contraction path optimization and execution is delegated to the EinExprs library. A EinExpr is a lower-level form of a Tensor Network, in which the contraction path has been laid out as a tree. It is similar to a symbolic expression (i.e. Expr) but in which every node represents an Einstein summation expression (aka einsum).","category":"page"},{"location":"contraction/","page":"Contraction","title":"Contraction","text":"einexpr(::TensorNetwork)\ncontract\ncontract!","category":"page"},{"location":"contraction/#EinExprs.einexpr-Tuple{TensorNetwork}","page":"Contraction","title":"EinExprs.einexpr","text":"einexpr(tn::TensorNetwork; optimizer = EinExprs.Greedy, output = inds(tn, :open), kwargs...)\n\nSearch a contraction path for the given TensorNetwork and return it as a EinExpr.\n\nKeyword Arguments\n\noptimizer Contraction path optimizer. Check EinExprs documentation for more info.\noutputs Indices that won't be contracted. Defaults to open indices.\nkwargs Options to be passed to the optimizer.\n\nSee also: contract.\n\n\n\n\n\n","category":"method"},{"location":"contraction/#Tenet.contract","page":"Contraction","title":"Tenet.contract","text":"contract(a::Tensor[, b::Tensor, dims=nonunique([inds(a)..., inds(b)...])])\n\nPerform tensor contraction operation.\n\n\n\n\n\ncontract(tn::TensorNetwork; kwargs...)\n\nContract a TensorNetwork. The contraction order will be first computed by einexpr.\n\nThe kwargs will be passed down to the einexpr function.\n\nSee also: einexpr, contract!.\n\n\n\n\n\n","category":"function"},{"location":"contraction/#Tenet.contract!","page":"Contraction","title":"Tenet.contract!","text":"contract!(tn::TensorNetwork, index::Symbol)\n\nIn-place contraction of tensors connected to index.\n\nSee also: contract.\n\n\n\n\n\n","category":"function"},{"location":"examples/google-rqc/#Google's-Quantum-Advantage-experiment","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"","category":"section"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"info: Dependencies ðŸ“¦\nThis example uses QuacIO and EinExprs in combination with Tenet. Both packages can be found in Quantic's registry and can be installed in Pkg mode.add QuacIO EinExprsIt also requires the circuit in sycamore_m53_d10.qasm file that can be found in ... This is a shorter version of the real circuit used for the experiment.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"In 2019, Google rushed to claim quantum advantage[1] for the first time ever. The article was highly criticized and one year later, J. Gray et al.[2] disproved the claim by developing a better heuristic search for contraction path that improved the previous cost by times 10^4.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"[1]: The first used term was quantum supremacy although the community transitioned to quantum advantage due to political reasons. However, Google uses the term beyond classical. It is then not uncommon to find different terms to refer to the same thing: the moment in which quantum computers surpass classical computers on solving some problem.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"[2]: J. Gray et al. \"Hyper-Optimized Tensor Network Contraction\" (2020)","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"Since then, several teams and companies have come and go, proposing and disproving several experiments. But in this example, we focus on the original Google experiment.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"The experiment consisted on sampling Random Quantum Circuits (RQC). The state of the systems after these circuits follow a distribution similar, but not equal to the uniform distribution.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"...","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"Thanks to Tenet's much cared design, the experiment can be replicated conceptually in less than 20loc.","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"using QuacIO\nusing Tenet\n\n_sites = [5, 6, 14, 15, 16, 17, 24, 25, 26, 27, 28, 32, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 61, 62, 63, 64, 65, 66, 67, 72, 73, 74, 75, 76, 83, 84, 85, 94];\n\n# load circuit and convert to `TensorNetwork`\ncircuit = QuacIO.parse(joinpath(@__DIR__, \"sycamore_53_10_0.qasm\"), format = QuacIO.Qflex(), sites = _sites);\ntn = TensorNetwork(circuit)\nplot(tn) # hide","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"# simplify Tensor Network by preemptively contracting trivial cases\ntn = transform(tn, Tenet.RankSimplification)\nplot(tn) # hide","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"using Distributed\n\naddprocs(10)\n@everywhere using Tenet, EinExprs\n\n# parallel stochastic contraction path search\n@everywhere tn = $tn\npath = @distributed (x -> minimum(flops, x...)) for _ in 1:100\n    einexpr(tn, optimizer = Greedy)\nend","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"using EinExprs # hide\nusing NetworkLayout # hide\npath = einexpr(tn, optimizer = Greedy) # hide\nplot(path, layout=Stress()) # hide","category":"page"},{"location":"examples/google-rqc/","page":"Google's Quantum Advantage experiment","title":"Google's Quantum Advantage experiment","text":"using Iterators: product\n\n# parallel sliced contraction\n# NOTE `slices` not implemented yet\ncuttings = [[i => dim for dim in 1:size(tn,i)] for i in findslices(FlopsScorer(), path, slices=100)]\n\n@everywhere path = $path\nres = @distributed (+) for proj_inds in product(cuttings...)\n    slice = @view path[proj_inds...]\n    contract(slice)\nend","category":"page"},{"location":"quantum/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"In Tenet, we define a Quantum Tensor Network as a TensorNetwork with a notion of sites and directionality.","category":"page"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"Quantum","category":"page"},{"location":"quantum/#Tenet.Quantum","page":"Introduction","title":"Tenet.Quantum","text":"Quantum <: Ansatz\n\nTensor Network Ansatz that has a notion of sites and directionality (input/output).\n\n\n\n\n\n","category":"type"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"plug","category":"page"},{"location":"quantum/#Tenet.plug","page":"Introduction","title":"Tenet.plug","text":"plug(::TensorNetwork{<:Quantum})\nplug(::Type{<:TensorNetwork})\n\nReturn the Plug type of the TensorNetwork. The following Plugs are defined in Tenet:\n\nState Only outputs.\nOperator Inputs and outputs.\nProperty No inputs nor outputs.\n\n\n\n\n\n","category":"function"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"sites","category":"page"},{"location":"quantum/#Tenet.sites","page":"Introduction","title":"Tenet.sites","text":"sites(tn::TensorNetwork{<:Quantum})\n\nReturn the sites in which the TensorNetwork acts.\n\n\n\n\n\n","category":"function"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"tensors(::TensorNetwork{<:Quantum}, ::Integer)","category":"page"},{"location":"quantum/#Tenet.tensors-Tuple{TensorNetwork{<:Quantum}, Integer}","page":"Introduction","title":"Tenet.tensors","text":"tensors(tn::TensorNetwork{<:Quantum}, site::Integer)\n\nReturn the Tensor connected to the TensorNetwork on site.\n\nSee also: sites.\n\n\n\n\n\n","category":"method"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"boundary","category":"page"},{"location":"quantum/#Tenet.boundary","page":"Introduction","title":"Tenet.boundary","text":"boundary(::TensorNetwork)\nboundary(::Type{<:TensorNetwork})\n\nReturn the Boundary type of the TensorNetwork. The following Boundarys are defined in Tenet:\n\nOpen\nPeriodic\nInfinite\n\n\n\n\n\n","category":"function"},{"location":"quantum/#Adjoint","page":"Introduction","title":"Adjoint","text":"","category":"section"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"adjoint","category":"page"},{"location":"quantum/#Base.adjoint","page":"Introduction","title":"Base.adjoint","text":"adjoint(tn::TensorNetwork{<:Quantum})\n\nReturn the adjoint TensorNetwork.\n\nImplementation details\n\nThe tensors are not transposed, just conj! is applied to them.\n\n\n\n\n\n","category":"function"},{"location":"quantum/#Concatenation","page":"Introduction","title":"Concatenation","text":"","category":"section"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"hcat(::TensorNetwork{<:Quantum}, ::TensorNetwork{<:Quantum})","category":"page"},{"location":"quantum/#Base.hcat-Tuple{TensorNetwork{<:Quantum}, TensorNetwork{<:Quantum}}","page":"Introduction","title":"Base.hcat","text":"hcat(A::TensorNetwork{<:Quantum}, B::TensorNetwork{<:Quantum}...)::TensorNetwork{<:Composite}\n\nJoin TensorNetworks into one by matching sites.\n\n\n\n\n\n","category":"method"},{"location":"quantum/#Norm","page":"Introduction","title":"Norm","text":"","category":"section"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"LinearAlgebra.norm(::TensorNetwork{<:Quantum}, p::Real)\nLinearAlgebra.normalize!(::TensorNetwork{<:Quantum}, ::Real)","category":"page"},{"location":"quantum/#LinearAlgebra.norm-Tuple{TensorNetwork{<:Quantum}, Real}","page":"Introduction","title":"LinearAlgebra.norm","text":"norm(Ïˆ::TensorNetwork{<:Quantum}, p::Real=2)\n\nCompute the p-norm of a Quantum TensorNetwork.\n\nSee also: normalize!.\n\n\n\n\n\n","category":"method"},{"location":"quantum/#LinearAlgebra.normalize!-Tuple{TensorNetwork{<:Quantum}, Real}","page":"Introduction","title":"LinearAlgebra.normalize!","text":"normalize!(Ïˆ::TensorNetwork{<:Quantum}, p::Real = 2; insert::Union{Nothing,Int} = nothing)\n\nIn-place normalize the TensorNetwork.\n\nKeyword Arguments\n\ninsert Choose the way the normalization is performed:\nIf insert=nothing (default), then all tensors are divided by sqrtnlVert psi rVert_p where n is the number of tensors.\nIf insert isa Integer, then the tensor connected to the site pointed by insert is divided by the norm.\nBoth approaches are mathematically equivalent. Choose between them depending on the numerical properties.\n\nSee also: norm.\n\n\n\n\n\n","category":"method"},{"location":"quantum/#Fidelity","page":"Introduction","title":"Fidelity","text":"","category":"section"},{"location":"quantum/","page":"Introduction","title":"Introduction","text":"fidelity","category":"page"},{"location":"quantum/#Tenet.fidelity","page":"Introduction","title":"Tenet.fidelity","text":"fidelity(Ïˆ,Ï•)\n\nCompute the fidelity between states ketpsi and ketphi.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"In tensor network computations, it is good practice to apply various transformations to simplify the network structure, reduce computational cost, or prepare the network for further operations. These transformations modify the network's structure locally by permuting, contracting, factoring or truncating tensors.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"A crucial reason why these methods are indispensable lies in their ability to drastically reduce the problem size of the contraction path search and also the contraction. This doesn't necessarily involve reducing the maximum rank of the Tensor Network itself, but more importantly, it reduces the size (or rank) of the involved tensors.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Our approach has been significantly inspired by the ideas presented in the Quimb library, explained in this paper.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"In Tenet, we provide a set of predefined transformations which you can apply to your TensorNetwork using both the transform/transform! functions.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"transform\ntransform!","category":"page"},{"location":"transformations/#Tenet.transform","page":"Transformations","title":"Tenet.transform","text":"transform(tn::TensorNetwork, config::Transformation)\ntransform(tn::TensorNetwork, configs)\n\nReturn a new TensorNetwork where some Transformation has been performed into it.\n\nSee also: transform!.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Tenet.transform!","page":"Transformations","title":"Tenet.transform!","text":"transform!(tn::TensorNetwork, config::Transformation)\ntransform!(tn::TensorNetwork, configs)\n\nIn-place version of transform.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Example","page":"Transformations","title":"Example","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Here we show how can we reduce the complexity of the tensor network by applying a tranformation to it:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")\n\nusing Pkg\nPkg.add(\"QuacIO\")","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"using QuacIO\nusing CairoMakie\nusing Tenet\n\nsites = [5, 6, 14, 15, 16, 17, 24, 25, 26, 27, 28, 32, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 61, 62, 63, 64, 65, 66, 67, 72, 73, 74, 75, 76, 83, 84, 85, 94]\ncircuit = QuacIO.parse(joinpath(@__DIR__, \"sycamore_53_10_0.qasm\"), format=QuacIO.Qflex(), sites=sites)\ntn = TensorNetwork(circuit)\ntransformed_tn = transform(tn, Tenet.RankSimplification)\n\nfig = Figure() # hide\nax1 = Axis(fig[1, 1]; title=\"Original TensorNetwork\") # hide\np1 = plot!(ax1, tn; node_size=5.) # hide\nax2 = Axis(fig[1, 2], title=\"Transformed TensorNetwork\") # hide\np2 = plot!(ax2, transformed_tn; node_size=5.) # hide\nax1.titlesize=20 # hide\nax2.titlesize=20 # hide\nfig # hide","category":"page"},{"location":"transformations/#Transformations-2","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Tenet.HyperindConverter\nTenet.DiagonalReduction\nTenet.RankSimplification\nTenet.AntiDiagonalGauging\nTenet.ColumnReduction\nTenet.SplitSimplification","category":"page"},{"location":"transformations/#Tenet.HyperindConverter","page":"Transformations","title":"Tenet.HyperindConverter","text":"HyperindConverter <: Transformation\n\nConvert hyperindices to COPY-tensors, represented by DeltaArrays.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#Tenet.DiagonalReduction","page":"Transformations","title":"Tenet.DiagonalReduction","text":"DiagonalReduction <: Transformation\n\nReduce the dimension of a Tensor in a TensorNetwork when it has a pair of indices that fulfil a diagonal structure.\n\nKeyword Arguments\n\natol Absolute tolerance. Defaults to 1e-12.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#Tenet.RankSimplification","page":"Transformations","title":"Tenet.RankSimplification","text":"RankSimplification <: Transformation\n\nPreemptively contract tensors whose result doesn't increase in size.\n\n\n\n\n\n","category":"type"},{"location":"transformations/#Tenet.AntiDiagonalGauging","page":"Transformations","title":"Tenet.AntiDiagonalGauging","text":"AntiDiagonalGauging <: Transformation\n\nReverse the order of tensor indices that fulfill the anti-diagonal condition. While this transformation doesn't directly enhance computational efficiency, it sets up the TensorNetwork for other operations that do.\n\nKeyword Arguments\n\natol Absolute tolerance. Defaults to 1e-12.\nskip List of indices to skip. Defaults to [].\n\n\n\n\n\n","category":"type"},{"location":"transformations/#Tenet.ColumnReduction","page":"Transformations","title":"Tenet.ColumnReduction","text":"ColumnReduction <: Transformation\n\nTruncate the dimension of a Tensor in a TensorNetwork when it contains columns with all elements smaller than atol.\n\nKeyword Arguments\n\natol Absolute tolerance. Defaults to 1e-12.\nskip List of indices to skip. Defaults to [].\n\n\n\n\n\n","category":"type"},{"location":"transformations/#Tenet.SplitSimplification","page":"Transformations","title":"Tenet.SplitSimplification","text":"SplitSimplification <: Transformation\n\nReduce the rank of tensors in the TensorNetwork by decomposing them using the Singular Value Decomposition (SVD). Tensors whose factorization do not increase the maximum rank of the network are left decomposed.\n\nKeyword Arguments\n\natol Absolute tolerance. Defaults to 1e-10.\n\n\n\n\n\n","category":"type"},{"location":"quantum/mps/#Matrix-Product-States-(MPS)","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"","category":"section"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"Matrix Product States (MPS) are a Quantum Tensor Network ansatz whose tensors are laid out in a 1D chain. Due to this, these networks are also known as Tensor Trains in other mathematical fields. Depending on the boundary conditions, the chains can be open or closed (i.e. periodic boundary conditions).","category":"page"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"using Makie\nMakie.inline!(true)\nset_theme!(resolution=(800,200))\n\nusing CairoMakie\n\nusing Tenet\nusing NetworkLayout","category":"page"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"fig = Figure() # hide\n\ntn_open = rand(MatrixProduct{State,Open}, n=10, Ï‡=4) # hide\ntn_periodic = rand(MatrixProduct{State,Periodic}, n=10, Ï‡=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\nplot!(fig[1,2], tn_periodic, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"quantum/mps/#Matrix-Product-Operators-(MPO)","page":"Matrix Product States (MPS)","title":"Matrix Product Operators (MPO)","text":"","category":"section"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"Matrix Product Operators (MPO) are the operator version of Matrix Product State (MPS). The major difference between them is that MPOs have 2 indices per site (1 input and 1 output) while MPSs only have 1 index per site (i.e. an output).","category":"page"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"fig = Figure() # hide\n\ntn_open = rand(MatrixProduct{Operator,Open}, n=10, Ï‡=4) # hide\ntn_periodic = rand(MatrixProduct{Operator,Periodic}, n=10, Ï‡=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\nplot!(fig[1,2], tn_periodic, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"In Tenet, the generic MatrixProduct ansatz implements this topology. Type variables are used to address their functionality (State or Operator) and their boundary conditions (Open or Periodic).","category":"page"},{"location":"quantum/mps/","page":"Matrix Product States (MPS)","title":"Matrix Product States (MPS)","text":"MatrixProduct\nMatrixProduct(::Any)","category":"page"},{"location":"quantum/mps/#Tenet.MatrixProduct","page":"Matrix Product States (MPS)","title":"Tenet.MatrixProduct","text":"MatrixProduct{P<:Plug,B<:Boundary} <: Quantum\n\nA generic ansatz representing Matrix Product State (MPS) and Matrix Product Operator (MPO) topology, aka Tensor Train. Type variable P represents the Plug type (State or Operator) and B represents the Boundary type (Open or Periodic).\n\nAnsatz Fields\n\nÏ‡::Union{Nothing,Int} Maximum virtual bond dimension.\n\n\n\n\n\n","category":"type"},{"location":"quantum/mps/#Tenet.MatrixProduct-Tuple{Any}","page":"Matrix Product States (MPS)","title":"Tenet.MatrixProduct","text":"MatrixProduct{P,B}(arrays::AbstractArray[]; Ï‡::Union{Nothing,Int} = nothing, order = defaultorder(MatrixProduct{P}))\n\nConstruct a TensorNetwork with MatrixProduct ansatz, from the arrays of the tensors.\n\nKeyword Arguments\n\nÏ‡ Maximum virtual bond dimension. Defaults to nothing.\norder Order of tensor indices on arrays. Defaults to (:l, :r, :o) if P is a State, (:l, :r, :i, :o) if Operator.\n\n\n\n\n\n","category":"method"},{"location":"alternatives/#Alternatives","page":"Alternatives","title":"Alternatives","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Tenet is strongly opinionated. We acknowledge that it may not suit all cases (although we try ðŸ™‚). If your case doesn't fit Tenet's design, you can try the following libraries:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"quimb Flexible Tensor Network written in Python. Main source of inspiration for Tenet.\ntenpy Tensor Network library written in Python with a strong focus on physics.\nITensors.jl Mature Tensor Network framework written in Julia.\ntensorkrowch A new Tensor Network library built on top of PyTorch.","category":"page"},{"location":"quantum/peps/#Projected-Entangled-Pair-States-(PEPS)","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"","category":"section"},{"location":"quantum/peps/","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"Projected Entangled Pair States (PEPS) are a Quantum Tensor Network ansatz whose tensors are laid out in a 2D lattice. Depending on the boundary conditions, the chains can be open or closed (i.e. periodic boundary conditions).","category":"page"},{"location":"quantum/peps/","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"using Makie\nMakie.inline!(true)\nset_theme!(resolution=(800,400))\n\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\n\nusing Tenet\nusing NetworkLayout","category":"page"},{"location":"quantum/peps/","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"fig = Figure() # hide\n\ntn_open = rand(PEPS{Open}, rows=10, cols=10, Ï‡=4) # hide\ntn_periodic = rand(PEPS{Periodic}, rows=10, cols=10, Ï‡=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Stress(seed=1)) # hide\nplot!(fig[1,2], tn_periodic, layout=Stress(seed=10,dim=2,iterations=100000)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"quantum/peps/#Projected-Entangled-Pair-Operators-(PEPO)","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair Operators (PEPO)","text":"","category":"section"},{"location":"quantum/peps/","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"fig = Figure() # hide\n\ntn_open = rand(PEPO{Open}, rows=10, cols=10, Ï‡=4) # hide\ntn_periodic = rand(PEPO{Periodic}, rows=10, cols=10, Ï‡=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Stress(seed=1)) # hide\nplot!(fig[1,2], tn_periodic, layout=Stress(seed=10,dim=2,iterations=100000)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"quantum/peps/","page":"Projected Entangled Pair States (PEPS)","title":"Projected Entangled Pair States (PEPS)","text":"ProjectedEntangledPair\nProjectedEntangledPair(::Any)","category":"page"},{"location":"quantum/peps/#Tenet.ProjectedEntangledPair","page":"Projected Entangled Pair States (PEPS)","title":"Tenet.ProjectedEntangledPair","text":"ProjectedEntangledPair{P<:Plug,B<:Boundary} <: Quantum\n\nA generic ansatz representing Projected Entangled Pair States (PEPS) and Projected Entangled Pair Operators (PEPO). Type variable P represents the Plug type (State or Operator) and B represents the Boundary type (Open or Periodic).\n\nAnsatz Fields\n\nÏ‡::Union{Nothing,Int} Maximum virtual bond dimension.\n\n\n\n\n\n","category":"type"},{"location":"quantum/peps/#Tenet.ProjectedEntangledPair-Tuple{Any}","page":"Projected Entangled Pair States (PEPS)","title":"Tenet.ProjectedEntangledPair","text":"ProjectedEntangledPair{P,B}(arrays::Matrix{AbstractArray}; Ï‡::Union{Nothing,Int} = nothing, order = defaultorder(ProjectedEntangledPair{P}))\n\nConstruct a TensorNetwork with ProjectedEntangledPair ansatz, from the arrays of the tensors.\n\nKeyword Arguments\n\nÏ‡ Maximum virtual bond dimension. Defaults to nothing.\norder Order of the tensor indices on arrays. Defaults to (:l, :r, :u, :d, :o) if P is a State, (:l, :r, :u, :d, :i, :o) if Operator.\n\n\n\n\n\n","category":"method"},{"location":"#Tenet.jl","page":"Home","title":"Tenet.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Status: Alpha stage ðŸš§\nTenet is currently in a design stage and thus, the public API might change without notification. We do follow Julia's SemVer specification, so until we arrive to v1.0, patch version upgrades won't break the interface but minor version upgrades might.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia library for Tensor Networks. Tenet can be executed both at local environments and on large supercomputers. Its goals are,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expressiveness Simple to use ðŸ‘¶\nFlexibility Extend it to your needs ðŸ”§\nPerformance Goes brr... fast ðŸŽï¸","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: BSC-Quantic's Registry\nTenet and some of its dependencies are located in our own Julia registry. In order to download Tenet, add our registry to your Julia installation by using the Pkg mode in a REPL session,]registry add https://github.com/bsc-quantic/Registryor using the Pkg package directly,using Pkg\npkg\"registry add https://github.com/bsc-quantic/Registry\"","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Optimized Tensor Network contraction, powered by EinExprs\nTensor Network slicing/cuttings\nAutomatic Differentiation of TN contraction, powered by EinExprs and ChainRules\nQuantum Tensor Networks\nMatrix Product States (MPS)\nMatrix Product Operators (MPO)\n3D visualization of large networks, powered by Makie\nTranslation from quantum circuits, powered by Quac","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following feature are not yet implemented but are work in progress or are thought to be implemented in the near-mid future:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Distributed contraction\nQuantum Tensor Networks\nTree Tensor Networks (TTN)\nProjected Entangled Pair States (PEPS)\nMultiscale Entanglement Renormalization Ansatz (MERA)\nNumerical Tensor Network algorithms\nTensor Renormalization Group (TRG)\nDensity Matrix Renormalization Group (DMRG)","category":"page"},{"location":"tensor-network/#Tensor-Networks","page":"Introduction","title":"Tensor Networks","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"Tensor Networks (TN) are a graphical notation for representing complex multi-linear functions. For example, the following equation","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"sum_ijklmnop A_im B_ijp C_njk D_pkl E_mno F_ol","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"can be represented visually as","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"<figure>\n<img width=500 src=\"../assets/tn-sketch.svg\" alt=\"Sketch of a Tensor Network\">\n<figcaption>Sketch of a Tensor Network</figcaption>\n</figure>","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"The graph's nodes represent tensors and edges represent tensor indices.","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"In Tenet, these objects are represented by the TensorNetwork type.","category":"page"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"TensorNetwork","category":"page"},{"location":"tensor-network/#Tenet.TensorNetwork","page":"Introduction","title":"Tenet.TensorNetwork","text":"TensorNetwork{Ansatz}\n\nGraph of interconnected tensors, representing a multilinear equation. Graph vertices represent tensors and graph edges, tensor indices.\n\n\n\n\n\n","category":"type"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"Information about a TensorNetwork can be queried with the following functions.","category":"page"},{"location":"tensor-network/#Query-information","page":"Introduction","title":"Query information","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"inds(::TensorNetwork)\nsize(::TensorNetwork)\ntensors(::TensorNetwork)\nlength(::TensorNetwork)","category":"page"},{"location":"tensor-network/#EinExprs.inds-Tuple{TensorNetwork}","page":"Introduction","title":"EinExprs.inds","text":"inds(tn::TensorNetwork, set = :all)\n\nReturn the names of the indices in the TensorNetwork.\n\nKeyword Arguments\n\nset\n:all (default) All indices.\n:open Indices only mentioned in one tensor.\n:inner Indices mentioned at least twice.\n:hyper Indices mentioned at least in three tensors.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Base.size-Tuple{TensorNetwork}","page":"Introduction","title":"Base.size","text":"size(tn::TensorNetwork)\nsize(tn::TensorNetwork, index)\n\nReturn a mapping from indices to their dimensionalities.\n\nIf index is set, return the dimensionality of index. This is equivalent to size(tn)[index].\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Tenet.tensors-Tuple{TensorNetwork}","page":"Introduction","title":"Tenet.tensors","text":"tensors(tn::TensorNetwork)\n\nReturn a list of the Tensors in the TensorNetwork.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Base.length-Tuple{TensorNetwork}","page":"Introduction","title":"Base.length","text":"length(tn::TensorNetwork)\n\nReturn the number of Tensors in the TensorNetwork.\n\nSee also: tensors, size.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Modification","page":"Introduction","title":"Modification","text":"","category":"section"},{"location":"tensor-network/#Add/Remove-tensors","page":"Introduction","title":"Add/Remove tensors","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"push!(::TensorNetwork, ::Tensor)\nappend!(::TensorNetwork, ::Base.AbstractVecOrTuple{<:Tensor})\npop!(::TensorNetwork, ::Tensor)\ndelete!(::TensorNetwork, ::Any)","category":"page"},{"location":"tensor-network/#Base.push!-Tuple{TensorNetwork, Tensor}","page":"Introduction","title":"Base.push!","text":"push!(tn::TensorNetwork, tensor::Tensor)\n\nAdd a new tensor to the Tensor Network.\n\nSee also: append!, pop!.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Base.append!-Tuple{TensorNetwork, Union{Tuple{Vararg{var\"#s24\"}}, AbstractVector{<:var\"#s24\"}} where var\"#s24\"<:Tensor}","page":"Introduction","title":"Base.append!","text":"append!(tn::TensorNetwork, tensors::AbstractVecOrTuple{<:Tensor})\nappend!(A::TensorNetwork, B::TensorNetwork)\n\nAdd a list of tensors to the first TensorNetwork.\n\nSee also: push!\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Base.pop!-Tuple{TensorNetwork, Tensor}","page":"Introduction","title":"Base.pop!","text":"pop!(tn::TensorNetwork, tensor::Tensor)\npop!(tn::TensorNetwork, i::Union{Symbol,AbstractVecOrTuple{Symbol}})\n\nRemove a tensor from the Tensor Network and returns it. If a Tensor is passed, then the first tensor satisfies egality (i.e. â‰¡ or ===) will be removed. If a Symbol or a list of Symbols is passed, then remove and return the tensors that contain all the indices.\n\nSee also: push!, delete!.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Base.delete!-Tuple{TensorNetwork, Any}","page":"Introduction","title":"Base.delete!","text":"delete!(tn::TensorNetwork, x)\n\nLike pop! but return the TensorNetwork instead.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Replace-existing-elements","page":"Introduction","title":"Replace existing elements","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"replace\nreplace!","category":"page"},{"location":"tensor-network/#Base.replace","page":"Introduction","title":"Base.replace","text":"replace(tn::TensorNetwork, old => new...)\n\nReturn a copy of the TensorNetwork where old has been replaced by new.\n\nSee also: replace!.\n\n\n\n\n\n","category":"function"},{"location":"tensor-network/#Base.replace!","page":"Introduction","title":"Base.replace!","text":"replace!(tn::TensorNetwork, old => new...)\n\nReplace the element in old with the one in new. Depending on the types of old and new, the following behaviour is expected:\n\nIf Symbols, it will correspond to a index renaming.\nIf Tensors, first element that satisfies egality (â‰¡ or ===) will be replaced.\n\nSee also: replace.\n\n\n\n\n\n","category":"function"},{"location":"tensor-network/#Selection","page":"Introduction","title":"Selection","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"select\nselectdim\nslice!\nview(::TensorNetwork)","category":"page"},{"location":"tensor-network/#Tenet.select","page":"Introduction","title":"Tenet.select","text":"select(tn::TensorNetwork, i)\n\nReturn tensors whose indices match with the list of indices i.\n\n\n\n\n\n","category":"function"},{"location":"tensor-network/#Base.selectdim","page":"Introduction","title":"Base.selectdim","text":"selectdim(tn::TensorNetwork, index::Symbol, i)\n\nReturn a copy of the TensorNetwork where index has been projected to dimension i.\n\nSee also: view, slice!.\n\n\n\n\n\n","category":"function"},{"location":"tensor-network/#Tenet.slice!","page":"Introduction","title":"Tenet.slice!","text":"slice!(tn::TensorNetwork, index::Symbol, i)\n\nIn-place projection of index on dimension i.\n\nSee also: selectdim, view.\n\n\n\n\n\n","category":"function"},{"location":"tensor-network/#Base.view-Tuple{TensorNetwork}","page":"Introduction","title":"Base.view","text":"view(tn::TensorNetwork, index => i...)\n\nReturn a copy of the TensorNetwork where each index has been projected to dimension i. It is equivalent to a recursive call of selectdim.\n\nSee also: selectdim, slice!.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/#Miscelaneous","page":"Introduction","title":"Miscelaneous","text":"","category":"section"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"Base.copy(::TensorNetwork)","category":"page"},{"location":"tensor-network/#Base.copy-Tuple{TensorNetwork}","page":"Introduction","title":"Base.copy","text":"copy(tn::TensorNetwork)\n\nReturn a shallow copy of the TensorNetwork.\n\n\n\n\n\n","category":"method"},{"location":"tensor-network/","page":"Introduction","title":"Introduction","text":"Base.rand(::Type{TensorNetwork}, n::Integer, regularity::Integer)","category":"page"},{"location":"tensor-network/#Base.rand-Tuple{Type{TensorNetwork}, Integer, Integer}","page":"Introduction","title":"Base.rand","text":"rand(TensorNetwork, n::Integer, regularity::Integer; out = 0, dim = 2:9, seed = nothing, globalind = false)\n\nGenerate a random tensor network.\n\nArguments\n\nn Number of tensors.\nregularity Average number of indices per tensor.\nout Number of open indices.\ndim Range of dimension sizes.\nseed If not nothing, seed random generator with this value.\nglobalind Add a global 'broadcast' dimension to every tensor.\n\n\n\n\n\n","category":"method"}]
}
