import{_ as t,c as n,o as d,ai as a}from"./chunks/framework.CSTnc4QY.js";const p=JSON.parse('{"title":"Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"manual/interfaces.md","filePath":"manual/interfaces.md","lastUpdated":null}'),o={name:"manual/interfaces.md"};function i(l,e,r,s,c,f){return d(),n("div",null,e[0]||(e[0]=[a('<h1 id="interfaces" tabindex="-1">Interfaces <a class="header-anchor" href="#interfaces" aria-label="Permalink to &quot;Interfaces&quot;">​</a></h1><p>Julia doesn&#39;t have a formal definition of interface built into the language. Instead it relies on <a href="https://wikipedia.org/wiki/Duck_typing" target="_blank" rel="noreferrer">duck typing</a>. Any declaration of a formal interface is then the documentation written for it.</p><h2 id="man-interface-tensornetwork" tabindex="-1">TensorNetwork <a class="header-anchor" href="#man-interface-tensornetwork" aria-label="Permalink to &quot;TensorNetwork {#man-interface-tensornetwork}&quot;">​</a></h2><p>A <a href="/Tenet.jl/previews/PR314/manual/interfaces#man-interface-tensornetwork"><code>TensorNetwork</code> (interface)</a> is a collection of <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a>s forming a graph structure.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Required method</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="/Tenet.jl/previews/PR314/api/tensornetwork#Tenet.tensors"><code>tensors(tn)</code></a></td><td style="text-align:left;">Returns the list of <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a>s present in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>inds_set_all</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>inds_set_open</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>inds_set_inner</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>inds_set_hyper</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>replace!(tn, index =&gt; new_index)</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>replace!(tn, tensor =&gt; new_tensor)</code></td><td style="text-align:left;"></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">Todo</p><ul><li><p>Are <code>contract</code> and <code>contract!</code> required methods for the interface?</p></li><li><p>Is conversion to <code>TensorNetwork</code> a required method method for the interface?</p></li></ul></div><p>The <code>inds_set_all</code>, <code>inds_set_inner</code>, <code>inds_set_open</code> and <code>inds_set_hyper</code> are the underlying functions used by <code>inds(tn; set)</code>, so they are required for it to work.</p><div class="tip custom-block"><p class="custom-block-title">Todo</p><p>We are looking for a better way to add value-dispatch to <a href="/Tenet.jl/previews/PR314/api/tensornetwork#EinExprs.inds"><code>inds</code></a> (specifically, the <code>inds(tn; set)</code> method) without incurring in huge dynamic dispatch overhead (like the <code>Val</code>-dispatch method). We might be interested in studying the internal mechanism used in <a href="https://github.com/ztangent/ValSplit.jl" target="_blank" rel="noreferrer">ValSplit.jl</a>.</p></div><p>The following methods are optional but you might be interested on implementing them for performance purposes.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Method</th><th style="text-align:left;">Default definition</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>size(tn)</code></td><td style="text-align:left;">Get index sizes from <code>tensors(tn)</code></td><td style="text-align:left;">Returns a <code>Dict</code> that maps indices to their sizes</td></tr><tr><td style="text-align:left;"><code>size(tn, i)</code></td><td style="text-align:left;">Get first matching tensor from <code>tensors(tn)</code> and query to it</td><td style="text-align:left;">Returns the size of the given index <code>i</code></td></tr><tr><td style="text-align:left;"><code>arrays</code></td><td style="text-align:left;"><code>parent.(tensors(tn))</code></td><td style="text-align:left;">Returns the arrays wrapped by the <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a>s in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>ninds</code></td><td style="text-align:left;"><code>length(inds(tn))</code></td><td style="text-align:left;">Returns the number of indices in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>ntensors</code></td><td style="text-align:left;"><code>length(tensors(tn))</code></td><td style="text-align:left;">Returns the number of tensors contained in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>in(index, tn)</code></td><td style="text-align:left;"><code>in(index, inds(tn))</code></td><td style="text-align:left;">Returns <code>true</code> if <code>index</code> is a existing index in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>in(tensor, tn)</code></td><td style="text-align:left;"><code>in(tensor, tensors(tn))</code></td><td style="text-align:left;">Returns <code>true</code> if <code>tensor</code> is a existing <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a> in <code>tn</code></td></tr></tbody></table><h2 id="man-interface-pluggable" tabindex="-1">Pluggable <a class="header-anchor" href="#man-interface-pluggable" aria-label="Permalink to &quot;Pluggable {#man-interface-pluggable}&quot;">​</a></h2><p>A <a href="/Tenet.jl/previews/PR314/manual/interfaces#man-interface-pluggable"><code>Pluggable</code></a> is a <a href="/Tenet.jl/previews/PR314/manual/interfaces#man-interface-tensornetwork"><code>TensorNetwork</code></a> together with a mapping between <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a>s and open indices.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Required method</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="./@ref sites"><code>sites(tn)</code></a></td><td style="text-align:left;">Returns the list of <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a>s present in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>ind_at(tn, at)</code></td><td style="text-align:left;">Return the index linked to the <code>at</code> <code>Symbol</code></td></tr><tr><td style="text-align:left;"><code>site_at(tn, at)</code></td><td style="text-align:left;">Return the <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a> linked to the index <code>at</code></td></tr><tr><td style="text-align:left;"><code>inds_set_physical(tn)</code></td><td style="text-align:left;">Return the indices linked to <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a>; i.e. the ones behaving as physical indices</td></tr></tbody></table><table tabindex="0"><thead><tr><th style="text-align:left;">Method</th><th style="text-align:left;">Default definition</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>nsites(tn; kwargs...)</code></td><td style="text-align:left;"><code>length(sites(tn; kwargs...))</code></td><td style="text-align:left;">Returns the number of <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a>s present in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>in(site, tn)</code></td><td style="text-align:left;"><code>in(site, sites(tn))</code></td><td style="text-align:left;">Returns <code>true</code> if <code>site</code> exists in <code>tn</code></td></tr></tbody></table><div class="danger custom-block"><p class="custom-block-title">Danger</p><p>Do not just forward calls to <code>replace!(tn, index =&gt; new_index)</code> because it would break the mapping between <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Site"><code>Site</code></a>s and indices when a mapped index is replaced.</p></div><h2 id="man-interface-ansatz" tabindex="-1">Ansatz <a class="header-anchor" href="#man-interface-ansatz" aria-label="Permalink to &quot;Ansatz {#man-interface-ansatz}&quot;">​</a></h2><p>A <a href="/Tenet.jl/previews/PR314/manual/interfaces#man-interface-ansatz"><code>Ansatz</code></a> is a <a href="/Tenet.jl/previews/PR314/manual/interfaces#man-interface-tensornetwork"><code>TensorNetwork</code></a> together with a mapping between <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Lane"><code>Lane</code></a>s and <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a>s.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Required method</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="./@ref lanes"><code>lanes(tn)</code></a></td><td style="text-align:left;">Returns the list of <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Lane"><code>Lane</code></a>s present in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>tensor_at(tn, at)</code></td><td style="text-align:left;">Returns the <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a> linked to the <code>at</code> <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Lane"><code>Lane</code></a>. Dispatched through <code>tensors(tn; at::Lane)</code></td></tr><tr><td style="text-align:left;"><code>lattice(tn)</code></td><td style="text-align:left;">Returns the <a href="/Tenet.jl/previews/PR314/api/ansatz#Tenet.Lattice"><code>Lattice</code></a> associated to <code>tn</code></td></tr></tbody></table><table tabindex="0"><thead><tr><th style="text-align:left;">Method</th><th style="text-align:left;">Default definition</th><th style="text-align:left;">Brief description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>nlanes(tn)</code></td><td style="text-align:left;"><code>length(lanes(tn))</code></td><td style="text-align:left;">Returns the number of <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Lane"><code>Lane</code></a>s present in <code>tn</code></td></tr><tr><td style="text-align:left;"><code>in(lane, tn)</code></td><td style="text-align:left;"><code>in(lane, lanes(tn))</code></td><td style="text-align:left;">Returns <code>true</code> if <code>lane</code> exists in <code>tn</code></td></tr></tbody></table><div class="danger custom-block"><p class="custom-block-title">Danger</p><p>Do not just forward calls to <code>replace!(tn, index =&gt; new_index)</code> nor <code>replace!(tn, tensor =&gt; new_tensor)</code> because it would break the mapping between <a href="/Tenet.jl/previews/PR314/api/quantum#Tenet.Lane"><code>Lane</code></a>s and <a href="/Tenet.jl/previews/PR314/api/tensor#Tensor"><code>Tensor</code></a>s when a mapped [<code>Tensor</code>] is replaced.</p></div><p>DocumenterMermaid.MermaidScriptBlock([...])</p>',21)]))}const g=t(o,[["render",i]]);export{p as __pageData,g as default};
